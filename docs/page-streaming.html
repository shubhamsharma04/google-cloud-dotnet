<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Page streaming | Google Cloud APIs </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Page streaming | Google Cloud APIs ">
    <meta name="generator" content="docfx 2.3.0.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="page-streaming">Page streaming</h1>
              
<h2 id="introduction">Introduction</h2>
<p>Many Google APIs expose operations to list resources, possibly
filtering them. Often, there may be many, many matching resources,
so the results are returned one &quot;page&quot; at a time. Each request can
specify a <em>page token</em> which identifies the start of the page of
results to return, and each response specifies a <em>next page token</em>
to use in the subsequent request. If the end of the logical result
list has been reached, the next page token is not specified.</p>
<p>In addition to the resources in the page, a list response can
include extra information such as the total size of the list,
or perhaps the cost of performing the query.</p>
<p>The code required to iterate over all the results in a list is not
difficult, but it is tedious and error-prone, so the C# client
libraries have abstracted this away.</p>
<p>Operations listing resources synchronously return an
<a href="../obj/api/Google.Api.Gax.IPagedEnumerable-2.yml">IPagedEnumerable&lt;TResponse, TResource&gt;</a>, and operations listing
resources asynchronously return an
<a href="../obj/api/Google.Api.Gax.IPagedAsyncEnumerable-2.yml">IPagedAsyncEnumerable&lt;TResponse, TResource&gt;</a>.
These are equivalent other than their asynchrony, so
this document focuses on the synchronous version for simplicity.</p>
<p>The interfaces used in this document are the ones used by gRPC-based libraries.
REST-based libraries have equivalent interfaces in the <code>Google.Api.Gax.Rest</code> namespace.
They operate in exactly the same way for client code, but the generic type parameters
have slightly different constraints due to differences in the access protocol. See the
<a href="api-layers.html">API layers</a> documentation for more details about the differences between
gRPC-based and REST-based libraries.</p>
<h2 id="ipagedenumerable-tresponse-tresource"><code>IPagedEnumerable&lt;TResponse, TResource&gt;</code></h2>
<p>Let&#39;s look at the generic type parameters first. The <code>TResponse</code> is
the API response type for the list operation, and the <code>TResource</code> is
the type of the resource being listed. In the Pub/Sub API for
example, the <code>ListTopics</code> operation accepts a <code>ListTopicsRequest</code>
and returns a <code>ListTopicsResponse</code> containing a set of <code>Topic</code>
resources - so the <a href="Google.Pubsub.V1/api/Google.Pubsub.V1.PublisherClient.html#Google_Pubsub_V1_PublisherClient_ListTopics_System_String_System_String_System_Nullable_System_Int32__Google_Api_Gax_CallSettings_">PublisherClient.ListTopics</a>
method returns an <code>IPagedEnumerable&lt;ListTopicsResponse, Topic&gt;</code>.</p>
<p><code>IPagedEnumerable&lt;TResponse, TResource&gt;</code> implements
<code>IEnumerable&lt;TResource&gt;</code>.  If you simply iterate over it, you will
retrieve one resource at a time. The implementation will make API
calls as it needs to, retrieving a page at a time and then returning
the resources as the caller requests them.</p>
<h2 id="iresourceenumerable-tresponse-tresource"><code>IResourceEnumerable&lt;TResponse, TResource&gt;</code></h2>
<p>For more advanced scenarios, however, your application may need access
to the pages returned by the API instead. The
<a href="../obj/api/Google.Api.Gax.IPagedEnumerable-2.yml#Google_Api_Gax_IPagedEnumerable_2_AsPages">IPagedEnumerable&lt;TResponse, TResource&gt;.AsPages()</a>
method returns an <a href="../obj/api/Google.Api.Gax.IResponseEnumerable-2.yml">IResponseEnumerable&lt;TResponse, TResource&gt;</a> which
implements <code>IEnumerable&lt;TResponse&gt;</code>, so you can iterate over the responses easily. Each
response provides access to the individual resources within the page, and some APIs may
provide additional information such as the time taken for the request or the total number of
results across all pages. As you iterate over the pages, API requests are made
transparently, propagating the page token from one response to the next request.</p>
<p><code>IResourceEnumerable&lt;TResponse, TResource&gt;</code> provides one additional method, 
<a href="../obj/api/Google.Api.Gax.IResponseEnumerable-2.yml#Google_Api_Gax_IResponseEnumerable_2_WithFixedSize_System_Int32_">WithFixedSize()</a>
to cater for web applications which require precise page sizes.</p>
<p>Although APIs generally allow the application to specify the page size to return, this
is an upper limit rather than a hard requirement. It&#39;s possible for an API to return fewer results,
even if more are available - for example, if the server notices that it is close to reaching the specified
RPC deadline. While that&#39;s fine for many batch scenarios, it isn&#39;t ideal if the results are being presented to users,
where typically you want to provide the exact same number of results per page.</p>
<p>The <code>WithFixedSize</code> method makes multiple API requests if necessary, in order to &quot;fill&quot; each page
until it reaches the end of the resources being listed. The return value is an <code>IEnumerable&lt;FixedSizePage&lt;TResource&gt;&gt;</code>, where
<a href="../obj/api/Google.Api.Gax.FixedSizePage-1.yml#Google_Api_Gax_FixedSizePage_1">FixedSizePage&lt;TResource&gt;</a> provides the items
within each page, along with the page token used to retrieve the next page. (This would typically be used in a &quot;next page&quot; link
in the web results.)</p>
<h2 id="use-case-sample-code">Use case sample code</h2>
<h3 id="iterate-over-all-resources-ignoring-pagination">Iterate over all resources, ignoring pagination</h3>
<pre><code class="lang-cs">PublisherClient client = PublisherClient.Create();
string projectName = PublisherClient.FormatProjectName(projectId);
IPagedEnumerable&lt;ListTopicsResponse, Topic&gt; topics = client.ListTopics(projectName, pageSize: 3);
foreach (Topic topic in topics)
{
    Console.WriteLine(topic.Name);
}
</code></pre><h3 id="iterate-over-all-resources-remembering-page-tokens">Iterate over all resources, remembering page tokens</h3>
<pre><code class="lang-cs">PublisherClient client = PublisherClient.Create();
string projectName = PublisherClient.FormatProjectName(projectId);
IPagedEnumerable&lt;ListTopicsResponse, Topic&gt; topics = client.ListTopics(projectName, pageSize: 3);
IResponseEnumerable&lt;ListTopicsResponse, Topic&gt; topicPages = topics.AsPages();
foreach (ListTopicsResponse page in topicPages)
{
    Console.WriteLine(&quot;Topics in response:&quot;);
    foreach (Topic topic in page.Topics)
    {
        Console.WriteLine($&quot;  {topic.Name}&quot;);
    }
    // If you were processing items in batches, you might wish to store this
    // in order to recover from failures. The page token can be passed into the ListTopics method.
    Console.WriteLine($&quot;Next page token: {page.NextPageToken}&quot;);
}
</code></pre><h3 id="obtain-a-single-page-of-results">Obtain a single page of results</h3>
<pre><code class="lang-cs">PublisherClient client = PublisherClient.Create();
string projectName = PublisherClient.FormatProjectName(projectId);
IPagedEnumerable&lt;ListTopicsResponse, Topic&gt; topics = client.ListTopics(projectName, pageSize: 3);
IResponseEnumerable&lt;ListTopicsResponse, Topic&gt; topicPages = topics.AsPages();
// This is just the regular LINQ First() method. The sequence of pages will never be empty,
// but the page may have no resources.
ListTopicsResponse firstPage = topicPages.First();
Console.WriteLine(&quot;Topics in response:&quot;);
foreach (Topic topic in firstPage.Topics)
{
    Console.WriteLine($&quot;  {topic.Name}&quot;);
}
// If you were processing items in batches, you might wish to store this
// in order to recover from failures. The page token can be passed into the ListTopics method.
Console.WriteLine($&quot;Next page token: {firstPage.NextPageToken}&quot;);
</code></pre><h3 id="display-results-in-fixed-sized-pages">Display results in fixed-sized pages</h3>
<p>This is typically used in web applications.</p>
<pre><code class="lang-cs">PublisherClient client = PublisherClient.Create();
string projectName = PublisherClient.FormatProjectName(projectId);
IPagedEnumerable&lt;ListTopicsResponse, Topic&gt; topics = client.ListTopics(projectName, pageTokenFromRequest);

IEnumerable&lt;FixedSizePage&lt;Topic&gt;&gt; fixedSizePages = topics.AsPages().WithFixedSize(3);
// With fixed size pages, if there are no more resources, there are no more pages.
FixedSizePage&lt;Topic&gt; nextPage = fixedSizePages.FirstOrDefault();
if (nextPage != null)
{
    // In a web application, this would be a matter of including the topics in the web page.
    foreach (Topic topic in nextPage)
    {
        Console.WriteLine(topic.Name);
    }
    // ... and embedding the next page token into a &quot;next page&quot; link.
    Console.WriteLine($&quot;Next page token: {nextPage.NextPageToken}&quot;);
}
</code></pre><h2 id="feedback">Feedback</h2>
<p>We&#39;ve already been through a number of iterations of the page-streaming API,
but would very much welcome feedback on it. A few thoughts:</p>
<ul>
<li>We could return a concrete class rather than having the <code>IPagedEnumerable&lt;,&gt;</code>
interface. This would give us greater room for expansion in the future, but
might make faking harder.</li>
<li>We could move the <code>WithFixedSize</code> method into the returned type, so that
instead of calling <code>topics.AsPages().WithFixedSize(10)</code> you&#39;d call
<code>topics.WithFixedSizedPages(10)</code>, for example. This would allow us to remove
the <code>IResponseEnumerable&lt;,&gt;</code> interface.</li>
</ul>
<p>What other use cases should we consider? Does this meet your current needs?
Please <a href="https://github.com/GoogleCloudPlatform/google-cloud-dotnet/issues/new">raise an issue on github</a>
to provide feedback.</p>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
            <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
            </nav>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
             
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
